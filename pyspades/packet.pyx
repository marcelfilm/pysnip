# Copyright (c) Mathias Kaerlev 2011.# This file is part of pyspades.# pyspades program is free software: you can redistribute it and/or modify# it under the terms of the GNU General Public License as published by# the Free Software Foundation, either version 3 of the License, or# (at your option) any later version.# pyspades is distributed in the hope that it will be useful,# but WITHOUT ANY WARRANTY; without even the implied warranty of# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the# GNU General Public License for more details.# You should have received a copy of the GNU General Public License# along with pyspades.  If not, see <http://www.gnu.org/licenses/>.from pyspades.compression import decompress, compressfrom pyspades.common import *from pyspades.loaders import *from pyspades.loaders cimport Loader, PacketLoaderfrom pyspades import debugfrom pyspades.bytes cimport ByteReader, ByteWriter# 1 and 9 are the only unreliable packetsLOADERS = {    0 : Packet0,    1 : Ack,    2 : ConnectionRequest,    3 : ConnectionResponse,    4 : Disconnect,    5 : Ping,    # packet 6, 7, 8 and 9 are variabled-sized packets    6 : SizedData,    7 : Packet7,    8 : MapData,    9 : SizedSequenceData,    10 : Packet10,    11 : Packet11}def generate_loader_data(PacketLoader loader):    cdef ByteWriter reader = ByteWriter()    write_loader_data(reader, loader)    return reader    cdef inline void write_loader_data(ByteWriter reader, PacketLoader loader):    cdef int packet_id = loader.id    if loader.ack:        packet_id |= 0x80    reader.writeByte(packet_id, True)    reader.writeByte(loader.byte, True)    reader.writeShort(loader.sequence, True)    loader.write(reader)cdef class Packet:    cdef public:        int timer        int connection_id        int packet_id        int unique        list items        object data    def __init__(self):        self.connection_id = 0xFFF        def read(self, data):        cdef ByteReader reader = ByteReader(data)        cdef int value = reader.readShort(True)        cdef int flags = value & 0xC000        cdef int compressed = flags & 0x4000        cdef int timer = <int>(flags & 0x8000 != 0) # has timer?        self.unique = (value >> 12) & 3        self.connection_id = value & 0xFFF # if == 0xFFF CONNECTIONLESS        cdef int offset = 2 * timer + 2                if timer:            self.timer = reader.readShort(True)        else:            self.timer = -1                if compressed:            decompressed_data = decompress(data[offset:])            reader = ByteReader(decompressed_data)                self.items = []                cdef int loader_value, packet_id, byte, sequence        cdef PacketLoader loader                while reader.dataLeft():            loader_value = reader.readByte(True)            packet_id = loader_value & 0xF # should be under 12            if packet_id >= 12:                return            byte = reader.readByte(True)            sequence = reader.readShort(True)            loader = LOADERS[packet_id]()            loader.ack = (loader_value & 0x80) != 0            loader.sequence = sequence            loader.byte = byte            loader.read(reader)            self.items.append(loader)        def generate(self):        cdef int flags = 0        cdef PacketLoader item        cdef ByteWriter loader_writer        cdef bytes data        if self.data is None:            loader_writer = ByteWriter()            for item in self.items:                write_loader_data(loader_writer, item)            data = str(loader_writer)        else:            data = str(self.data)        cdef int size = len(data)        # only compress bigger packets        cdef bytes compressed        if size > 20:            compressed = compress(data)            if len(compressed) < size:                flags |= 0x4000                data = compressed        if self.timer != -1:            flags |= 0x8000        cdef int connection_id = self.connection_id        cdef int unique = self.unique        cdef int value = flags | ((unique & 3) << 12) | (connection_id & 0xFFF)        cdef ByteWriter reader = ByteWriter()        reader.writeShort(value, True)        if self.timer != -1:            reader.writeShort(self.timer, True)        reader.write(data)        return readerfrom pyspades import containedCONTAINED_LOADERS = {    0 : contained.PositionData,    1 : contained.OrientationData,    2 : contained.InputData,    4 : contained.GrenadePacket,    5 : contained.SetTool,    6 : contained.SetColor,    7 : contained.ExistingPlayer,    8 : contained.MoveObject,    9 : contained.CreatePlayer,    10 : contained.BlockAction,    11 : contained.StateData,    12 : contained.KillAction,    13 : contained.ChatMessage,    14 : contained.MapStart,    15 : contained.MapChunk,    16 : contained.PlayerLeft,    17 : contained.TerritoryCapture,    18 : contained.ProgressBar,    19 : contained.IntelCapture,    20 : contained.IntelPickup,    21 : contained.IntelDrop,    22 : contained.Restock,    23 : contained.FogColor,    24 : contained.WeaponReload,    25 : contained.ChangeTeam,    26 : contained.ChangeWeapon,    27 : contained.BasicServerMessage,    28 : contained.ServerMessage,    29 : contained.ServerLoadMessage}SERVER_LOADERS = CONTAINED_LOADERS.copy()SERVER_LOADERS.update({    3 : contained.SetHP})CLIENT_LOADERS = CONTAINED_LOADERS.copy()CLIENT_LOADERS.update({    3 : contained.HitPacket})def load_server_packet(data):    return load_contained_packet(data, SERVER_LOADERS)def load_client_packet(data):    return load_contained_packet(data, CLIENT_LOADERS)cdef inline Loader load_contained_packet(ByteReader data, dict table):    type = data.readByte(True)    return table[type](data)