# Copyright (c) Mathias Kaerlev 2011.# This file is part of pyspades.# pyspades is free software: you can redistribute it and/or modify# it under the terms of the GNU General Public License as published by# the Free Software Foundation, either version 3 of the License, or# (at your option) any later version.# pyspades is distributed in the hope that it will be useful,# but WITHOUT ANY WARRANTY; without even the implied warranty of# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the# GNU General Public License for more details.# You should have received a copy of the GNU General Public License# along with pyspades.  If not, see <http://www.gnu.org/licenses/>."""Reads/writes bytes"""from cStringIO import StringIOimport structclass ByteReader(object):    def __init__(self, *arg, **kw):        self.buffer = StringIO(*arg, **kw)        self.read = self.buffer.read        self.tell = self.buffer.tell        self.seek = self.buffer.seek        try:            self.write = self.buffer.write        except AttributeError:            pass        def readShort(self, unsigned = False, *arg, **kw):        if unsigned:            return self.readStruct('H', *arg, **kw)        else:            return self.readStruct('h', *arg, **kw)    def writeShort(self, value, unsigned = False, *arg, **kw):        if unsigned:            return self.writeStruct('H', value, *arg, **kw)        else:            return self.writeStruct('h', value, *arg, **kw)    def readByte(self, unsigned = False, *arg, **kw):        if unsigned:            return self.readStruct('B', *arg, **kw)        else:            return self.readStruct('b', *arg, **kw)    def writeByte(self, value, unsigned = False, *arg, **kw):        if unsigned:            return self.writeStruct('B', value, *arg, **kw)        else:            return self.writeStruct('b', value, *arg, **kw)        def readInt(self, unsigned = False, *arg, **kw):        if unsigned:            return self.readStruct('I', *arg, **kw)        else:            return self.readStruct('i', *arg, **kw)    def writeInt(self, value, unsigned = False, *arg, **kw):        if unsigned:            return self.writeStruct('I', value, *arg, **kw)        else:            return self.writeStruct('i', value, *arg, **kw)        def readFloat(self, *arg, **kw):        return self.readStruct('f', *arg, **kw)    def writeFloat(self, value, *arg, **kw):        return self.writeStruct('f', value, *arg, **kw)        def readStruct(self, format, big_endian = True):        if big_endian:            format = '!%s' % format        else:            format = '<%s' % format        size = struct.calcsize(format)        return struct.unpack(format, self.buffer.read(size))[0]    def writeStruct(self, format, value, big_endian = True):        if big_endian:            format = '!%s' % format        else:            format = '<%s' % format        self.buffer.write(struct.pack(format, value))        def dataLeft(self):        return len(self.buffer.getvalue()) -  self.buffer.tell()        def skipBytes(self, value):        self.buffer.seek(value, 1)        def rewind(self, value):        self.buffer.seek(-value, 1)        def readString(self):        data = ''        while 1:            c = self.read(1)            if c in ('\x00', ''):                break            data += c        return data        def writeString(self, value):        self.write(value + '\x00')        def readReader(self, size):        return ByteReader(self.read(size))        def __str__(self):        return self.buffer.getvalue()        def __len__(self):        return len(self.buffer.getvalue())