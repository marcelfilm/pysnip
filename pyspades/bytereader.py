# Copyright (c) Mathias Kaerlev 2011.# This file is part of pyspades.# pyspades is free software: you can redistribute it and/or modify# it under the terms of the GNU General Public License as published by# the Free Software Foundation, either version 3 of the License, or# (at your option) any later version.# pyspades is distributed in the hope that it will be useful,# but WITHOUT ANY WARRANTY; without even the implied warranty of# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the# GNU General Public License for more details.# You should have received a copy of the GNU General Public License# along with pyspades.  If not, see <http://www.gnu.org/licenses/>."""Reads/writes bytes"""from cStringIO import StringIOimport structSIGNED_SHORT_LE = struct.Struct('<h')SIGNED_SHORT_BE = struct.Struct('!h')UNSIGNED_SHORT_LE = struct.Struct('<H')UNSIGNED_SHORT_BE = struct.Struct('!H')SIGNED_BYTE_LE = struct.Struct('<b')SIGNED_BYTE_BE = struct.Struct('!b')UNSIGNED_BYTE_LE = struct.Struct('<B')UNSIGNED_BYTE_BE = struct.Struct('!B')SIGNED_INT_LE = struct.Struct('<i')SIGNED_INT_BE = struct.Struct('!i')UNSIGNED_INT_LE = struct.Struct('<I')UNSIGNED_INT_BE = struct.Struct('!I')FLOAT_LE = struct.Struct('<f')FLOAT_BE = struct.Struct('!f')class ByteReader(object):    def __init__(self, *arg, **kw):        self.buffer = StringIO(*arg, **kw)        self.read = self.buffer.read        self.tell = self.buffer.tell        self.seek = self.buffer.seek        try:            self.write = self.buffer.write        except AttributeError:            pass        def readShort(self, unsigned = False, big_endian = True):        if unsigned:            if big_endian:                f = UNSIGNED_SHORT_BE            else:                f = UNSIGNED_SHORT_LE        else:            if big_endian:                f = SIGNED_SHORT_BE            else:                f = SIGNED_SHORT_LE        return self.readStruct(f)    def writeShort(self, value, unsigned = False, big_endian = True):        if unsigned:            if big_endian:                f = UNSIGNED_SHORT_BE            else:                f = UNSIGNED_SHORT_LE        else:            if big_endian:                f = SIGNED_SHORT_BE            else:                f = SIGNED_SHORT_LE        return self.writeStruct(value, f)    def readByte(self, unsigned = False, big_endian = True):        if unsigned:            if big_endian:                f = UNSIGNED_BYTE_BE            else:                f = UNSIGNED_BYTE_LE        else:            if big_endian:                f = SIGNED_BYTE_BE            else:                f = SIGNED_BYTE_LE        return self.readStruct(f)    def writeByte(self, value, unsigned = False, big_endian = True):        if unsigned:            if big_endian:                f = UNSIGNED_BYTE_BE            else:                f = UNSIGNED_BYTE_LE        else:            if big_endian:                f = SIGNED_BYTE_BE            else:                f = SIGNED_BYTE_LE        return self.writeStruct(value, f)        def readInt(self, unsigned = False, big_endian = True):        if unsigned:            if big_endian:                f = UNSIGNED_INT_BE            else:                f = UNSIGNED_INT_LE        else:            if big_endian:                f = SIGNED_INT_BE            else:                f = SIGNED_INT_LE        return self.readStruct(f)    def writeInt(self, value, unsigned = False, big_endian = True):        if unsigned:            if big_endian:                f = UNSIGNED_INT_BE            else:                f = UNSIGNED_INT_LE        else:            if big_endian:                f = SIGNED_INT_BE            else:                f = SIGNED_INT_LE        return self.writeStruct(value, f)        def readFloat(self, big_endian = True):        if big_endian:            f = FLOAT_BE        else:            f = FLOAT_LE        return self.readStruct(f)    def writeFloat(self, value, big_endian = True):        if big_endian:            f = FLOAT_BE        else:            f = FLOAT_LE        return self.writeStruct(value, f)        def readStruct(self, format):        return format.unpack(self.buffer.read(format.size))[0]    def writeStruct(self, value, format):        self.buffer.write(format.pack(value))        def dataLeft(self):        return len(self.buffer.getvalue()) -  self.buffer.tell()        def skipBytes(self, value):        self.buffer.seek(value, 1)        def rewind(self, value):        self.buffer.seek(-value, 1)        def readString(self):        data = ''        while 1:            c = self.read(1)            if c in ('\x00', ''):                break            data += c        return data        def writeString(self, value):        self.write(value + '\x00')        def readReader(self, size):        return ByteReader(self.read(size))        def __str__(self):        return self.buffer.getvalue()        def __len__(self):        return len(self.buffer.getvalue())